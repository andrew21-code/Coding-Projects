import numpy as np
from scipy.interpolate import interp1d
from scipy.ndimage import convolve, gaussian_filter
import matplotlib.pyplot as plt

# --- PARAMETERS ---
N = 80           # Number of atoms per cell
L = 150          # Number of k-points
t = -2.7         # Hopping energy (eV)
a = 1.42      # C-C bond length (Å)

# Unit cell periodicities
a_uc_ZGNR = 2 * a               # Periodicity for ZGNR (along y)
a_uc_AGNR = np.sqrt(3) * a      # Periodicity for AGNR (along x) 

def site_index(n, sublattice, M):  
    """Map (n, sublattice) → single index"""
    return 2*n + sublattice

def build_H_ZGNR(ky, N, t, a_uc):
    """
    Builds the Bloch Hamiltonian H(ky) for ZGNR using the intra-cell (H0)
    and inter-cell (H1) hoppings derived from the unit cell.
    """
    H0 = np.zeros((N, N), dtype=complex) # Intra-cell (H_i,i)
    H1 = np.zeros((N, N), dtype=complex) # Inter-cell (H_i, i-1)
    
    M = N // 2

    # ==========================================================
    # 1. Intra-Cell Hoppings (H0)
    # Hoppings between atoms within the same cell 'i'
    # Connections: A_n <-> B_n (Vertical) and B_n <-> A_{n+1} (Diagonal)
    # ==========================================================
    H0 += np.diag(np.array([t]*(N-1)), k=1)  # Upper diagonal
    H0 += np.diag(np.array([t]*(N-1)), k=-1) # Lower diagonal

    # ==========================================================
    # 2. Inter-Cell Hoppings (H1)
    # Hoppings between atoms in cell 'i' and cell 'i-1'
    # Connections: A_{n-1} (i-1) → B_n (i)
    # ==========================================================
    
    for n in range(1, M):
        i_A = site_index(n, 0, M)           # A_n (White, current cell i)
        i_B_prev = site_index(n-1, 1, M)    # B_{n-1} (Dark, current cell i-1)

        i_B = site_index(n, 1, M)           # B_n (Black, current cell i)
        i_A_prev = site_index(n-1, 0, M)    # A_{n-1} (White, current cell i-1)

        # H_{i, i-1} term (H1): A_n (in i) <-> B_{n-1} (in i-1)
        H1[i_A, i_B_prev] = t

        # H_{i, i-1} term (H1): B_n (in i) <-> A_{n-1} (in i-1)
        # H1[i_B, i_A_prev] = t

        
    # ==========================================================
    # 3. Construct Bloch Hamiltonian H(ky)
    # ==========================================================
    
    # H1† is the Hermitian conjugate of H1: H_i-1, i
    H1_dagger = H1.conj().T
    
    # H(ky) = H0 + H1 * exp(-i ky a_uc) + H1† * exp(+i ky a_uc)
    H = H0 + H1 * np.exp(-1j * ky * a_uc) + H1_dagger * np.exp(+1j * ky * a_uc)
    
    return H


def build_H_AGNR(ky, N, t, a_uc):
    """
    Builds the Bloch Hamiltonian H(ky) for AGNR using the intra-cell (H0)
    and inter-cell (H1) hoppings derived from the unit cell.
    """
    M = N // 2
    H0 = np.zeros((N, N), dtype=complex) # Intra-cell (H_i,i)
    H1 = np.zeros((N, N), dtype=complex) # Inter-cell (H_i, i-1)

    # ==========================================================
    # 1. Intra-Cell Hoppings (H0)
    # Hoppings between atoms within the same cell 'i'
    # Connections: A_n <-> B_n (Horizontal) and B_n <-> A_{n±1} (Diagonal)
    # ==========================================================
    
    for n in range(M):
        i_B = site_index(n, 1, M)       # B_n (Black)
        i_A = site_index(n, 0, M)       # A_n (White
        i_A_next = site_index((n+1), 0, M) # A_{n+1} (White, with periodic boundary)
        i_A_prev = site_index((n-1), 0, M) # A_{n-1} (White, with periodic boundary)

        # H0: A_n <-> B_n (Horizontal)
        if n%2 != 0:
            H0[i_A, i_B] = t
            H0[i_B, i_A] = t

        # H0: B_n <-> A_{n+1} (Diagonal)
        if n>0 and n < M - 1:
            H0[i_B, i_A_next] = t
            H0[i_A_next, i_B] = t
            
            H0[i_B, i_A_prev] = t
            H0[i_A_prev, i_B] = t

    # ==========================================================
    # 2. Inter-Cell Hoppings (H1)
    # Hoppings between atoms in cell 'i' and cell 'i-1'
    # Connections: A_n (i) <-> B_n (i-1) if n even
    # ==========================================================
    for n in range(0, M, 2):

        i_B = site_index(n, 1, M)           # B_n (Black, current cell i)
        i_A_prev = site_index(n, 0, M)      # A_n (White, previous cell i-1)

        # H_{i, i-1} term (H1): A_n (in i) <-> B_n (in i-1)
        H1[i_B, i_A_prev] = t

    # ==========================================================
    # 3. Construct Bloch Hamiltonian H(ky)
    # ==========================================================
    H1_dagger = H1.conj().T
    H = H0 + H1 * np.exp(-1j * ky * a_uc) + H1_dagger * np.exp(+1j * ky * a_uc)
    return H


# Compute band structures

k_values_ZGNR = np.linspace(-np.pi/a_uc_ZGNR, np.pi/a_uc_ZGNR, L)
k_values_AGNR = np.linspace(-np.pi/a_uc_AGNR, np.pi/a_uc_AGNR, L)
energies_ZGNR = []
energies_AGNR = []

for ky in k_values_ZGNR:
    H_ZGNR = build_H_ZGNR(ky, N, t, a_uc_ZGNR)
    eigs_ZGNR = np.linalg.eigvalsh(H_ZGNR)
    energies_ZGNR.append(eigs_ZGNR)

for kx in k_values_AGNR:
    H_AGNR = build_H_AGNR(kx, N, t, a_uc_AGNR)
    eigs_AGNR = np.linalg.eigvalsh(H_AGNR)
    energies_AGNR.append(eigs_AGNR)

# Convert to numpy arrays for easier indexing
energies_ZGNR = np.array(energies_ZGNR)
energies_AGNR = np.array(energies_AGNR)

bandgap_ZGNR = energies_ZGNR[L//2, N//2] - energies_ZGNR[L//2, N//2 - 1]
bandgap_AGNR = energies_AGNR[L//2, N//2] - energies_AGNR[L//2, N//2 - 1]
print(f"Bandgap of ZGNR: {bandgap_ZGNR:.4f} eV")
print(f"Bandgap of AGNR: {bandgap_AGNR:.4f} eV")


# Compute DOS
def compute_DOS(energies, num_bins=1000, energy_range=(-3, 3)):
    """
    Compute the Density of States (DOS) from the energy eigenvalues.
    """
    all_energies = energies.flatten()
    dos, bin_edges = np.histogram(all_energies, bins=num_bins, range=energy_range, density=True)
    bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2
    return dos, bin_centers

# Compute DOS for ZGNR and AGNR
dos_values_ZGNR, bin_centers_ZGNR = compute_DOS(energies_ZGNR)
dos_values_AGNR, bin_centers_AGNR = compute_DOS(energies_AGNR)

# Plotting the band structures
fig, axes = plt.subplots(1, 2, figsize=(12, 5))

# ZGNR Band Structure
for n in range(N):
    axes[0].plot(k_values_ZGNR, energies_ZGNR[:, n], color='blue', linewidth=1.5, alpha=0.7)
axes[0].axhline(0, color='gray', linestyle='--', alpha=0.5, label='Fermi level')
axes[0].set_title("Band Structure of Zigzag GNR", fontsize=12, fontweight='bold')
axes[0].set_xlabel("$k_y$ (1/Å)", fontsize=11)
axes[0].set_ylabel("Energy (eV)", fontsize=11)
axes[0].grid(True, alpha=0.3)
axes[0].legend()

# AGNR Band Structure
for n in range(N):
    axes[1].plot(k_values_AGNR, energies_AGNR[:, n], color='red', linewidth=1.5, alpha=0.7)
axes[1].axhline(0, color='gray', linestyle='--', alpha=0.5, label='Fermi level')
axes[1].set_title("Band Structure of Armchair GNR", fontsize=12, fontweight='bold')
axes[1].set_xlabel("$k_x$ (1/Å)", fontsize=11)
axes[1].set_ylabel("Energy (eV)", fontsize=11)
axes[1].grid(True, alpha=0.3)
axes[1].legend()

plt.tight_layout()
plt.show()

# Plotting the DOS

fig, axes = plt.subplots(1, 2, figsize=(12, 5))

# Smooth DOS using Gaussian filter for continuous appearance
dos_smooth_ZGNR = gaussian_filter(dos_values_ZGNR, sigma=2.0)
dos_smooth_AGNR = gaussian_filter(dos_values_AGNR, sigma=2.0)

# ZGNR DOS
axes[0].plot(bin_centers_ZGNR, dos_smooth_ZGNR, color='darkblue', linewidth=2.5, label='ZGNR')
axes[0].fill_between(bin_centers_ZGNR, dos_smooth_ZGNR, alpha=0.4, color='blue')
axes[0].axvline(0, color='gray', linestyle='--', alpha=0.5, label='Fermi level')
axes[0].set_title("DOS of Zigzag GNR", fontsize=12, fontweight='bold')
axes[0].set_xlabel("Energy (eV)", fontsize=11)
axes[0].set_ylabel("DOS (states/eV)", fontsize=11)
axes[0].grid(True, alpha=0.3)
axes[0].legend()

# AGNR DOS
axes[1].plot(bin_centers_AGNR, dos_smooth_AGNR, color='darkred', linewidth=2.5, label='AGNR')
axes[1].fill_between(bin_centers_AGNR, dos_smooth_AGNR, alpha=0.4, color='red')
axes[1].axvline(0, color='gray', linestyle='--', alpha=0.5, label='Fermi level')
axes[1].set_title("DOS of Armchair GNR", fontsize=12, fontweight='bold')
axes[1].set_xlabel("Energy (eV)", fontsize=11)
axes[1].set_ylabel("DOS (states/eV)", fontsize=11)
axes[1].grid(True, alpha=0.3)
axes[1].legend()

plt.tight_layout()
plt.show()

